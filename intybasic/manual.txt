>>>>>>>>>>>>>  IntyBASIC user's manual  <<<<<<<<<<<<<<<

                 by Oscar Toledo G.
       (c) Copyright 2014-2018 Oscar Toledo G.
                http://nanochess.org/
               E-mail: biyubi@gmail.com

First developed: Jan/14/2014
Last revision: Aug/06/2018.


>>>>>>>>>>>>>>  Legal notice

This software is provided 'as-is', without any express or implied warranty. 
In no event will the author be held liable for any damages or loss arising 
from the use of this software.

It is prohibited to modify, decompile, disassemble or reverse engineer this 
software.

All trademarks are property of their respective owners.


>>>>>>>>>>>>>>  Changes in this version

v1.4.0 Dec/27/2018  o Added contrib/accel.bas it shows how to move sprites
                      by fractions of pixel (contributed by intvnut)
                    o VOICE INIT now "shuts up" the Intellivision (contributed
                      by intvnut) and the initializatin is done in automatic
                      form at start of program.
                    o FLASH INIT SIZE to choose Flash memory size.
                    o Allows constants in DATA PACKED.
                    o Detects wrong flow of control (GOTO to PROCEDURE or
                      GOSUB to non-PROCEDURE)
                    o Tracker allows playing 8 channels of music (using ECS
                      PSG)
                    o Added ON expr FAST to avoid two instructions.
                    o Added MUSIC GOSUB, MUSIC RETURN, MUSIC VOLUME and
                      MUSIC SPEED.
                    o Generates warnings for AND/OR/XOR and small operators
                      non-parenthesized.
                    o Now direct CONT1, CONT2, CONT3 and CONT4 generate 8-bit
                      results.
                    o Solved bug where IF CONT.B0 THEN wouldn't work, also
                      ABS and SGN.
                    o Name mangling for assembler now uses original names,
                      easing assembler interface.
                    o Now detects failure of flow control when using GOTO
                      to jump wrongly between procedures.
                    o Support for local labels (using period character
                      before a label, uses last global label as prefix)
                    o Compatibility with Tutorvision consoles.

v1.2.9 Nov/07/2017  o Moved screen clearing at the very start of program
                      to avoid brief title screen in Sears Intellivision.
                    o Added missing C7 note in internal tables.
                    o MUSIC.PLAYING failed with MUSIC JUMP.
                    o More optimization saving flags state across
                      instructions.
                    o Solved bug in PEEK optimization when source address
                      was incremented between two PEEKs.
                    o More indications in manual, including documenting
                      CONT3 and CONT4.
                    o VOICE.AVAILABLE for checking Intellivoice available.
                    o VOICE.PLAYING for checking Intellivoice playing.

v1.2.8 Oct/07/2016  o Added DATA PACKED for fitting two letters per word.
                    o Added OPTION WARNINGS for enabling/disabling
                      warnings during compilation.
                    o Added OPTION EXPLICIT for generating errors for any
                      variable used not declared previously with DIM.
                    o Now 16-bits memory segment for JLP/CC3 has new
                      as1600 attributes "=RW" (required for LTO-Flash)
                    o Warns about weird constants in FOR TO

v1.2.7 Sep/08/2016  o Allows to concatenate lines using the character \
                      at the end of a line.
                    o Now optimizes access to arrays when using same index
                      even if different array or offset.
                    o Solved bug where DEFINE VARPTR swallowed one extra
                      lexical component.
                    o Solved bug where 1024-x*x generated wrong code.
                    o Solved bug where PRINT "string" as first statement
                      would write in non-screen memory.
                    o Minor edit in manual (definition of BORDER)

v1.2.6 Jul/31/2016  o Detects when PROCEDURE isn't finished at end of
                      source code. Also starting a new PROCEDURE without
                      closing the previous one now is an error instead of
                      a warning.
                    o Added DATA VARPTR to allow arrays of pointers to
                      arrays and/or variables.
                    o Generates warning when using DEFINE and requesting
                      more than 16 GRAM to define.
                    o Internal: the mode_select variable now preserves in
                      bit 0 the actual mode.
                    o Solved bugs in multiplication by 126 and 127.
                    o Solved bug in usage of JLP acceleration. (wrongly
                      cached registers)
                    o Corrected contrib/clowns.bas (catsfolly) it broke
                      with a change in constants.bas
                    o Added contrib/Gram2GromFont.bas (GroovyBee) showing
                      how to take the GROM font and creating an entirely
                      new font.
                    o Added contrib/TinyFont.bas (GroovyBee) showing how
                      to display 40 columns using a 4 pixel wide font.
                    o Added manual notes about assembly language 
                      conventions for USR and CALL.

v1.2.5 Feb/16/2016  o Added UNSIGNED statement, allows to make unsigned
                      comparisons.
                    o Added PLAY VOLUME statement.
                    o Added NO DRUMS syntax to PLAY.
                    o Added MUSIC JUMP statement.
                    o Added MUSIC.PLAYING expression.
                    o Added CALL statement (like USR but outside expressions)
                    o DATA allows for string literal.
                    o DO statement followed by colon now isn't taken as
                      label.
                    o Corrected bug in PAL detection.
                    o Updated constants.bas (corrections and new constants
                      for Coloured Squares mode) and keypad.bas sample.
                    o Added contrib/ColouredSquares.bas a sample of drawing
                      lines in Coloured Squares mode by GroovyBee.
                    o Added samples/bats.bas (animated bats)
                    o Added samples/envelope.bas (using envelope sounds)

v1.2.4 Sep/25/2015  o Optimizes sequences of ANDI/XORI instructions.
                    o Gives warning in case of variable assignment to name
                      previously used with CONST.
                    o Solved bug where ELSEIF should be finished with ELSE.
                    o A few warnings emitted wrongly an error code.
                    o Warns about assignment to internal variable names.

v1.2.3 Sep/01/2015  o Added SIGNED statement to indicate arrays or variables
                      of 8-bits signed.
                    o SPRITE statement now allows expression on MOB index.
                    o SCREEN allows for sixth argument to support a wide
                      origin screen, useful for horizontal scrolling or to
                      display a fraction of a big map.
                    o Solved bug where warnings were treated as errors for
                      final return code of command line.
                    o Solved bug where some warnings couldn't be disabled.
                    o New sample: landscape.bas (additional SCREEN syntax)

v1.2.2 Aug/24/2015  o New FLASH statement allowing access of Flash memory
                      available in JLP cartridges.
                    o New FLASH.FIRST and FLASH.LAST read-only variables.
                    o Added new sample: flash.bas
                    o Added new contribution: 42k.bas (GroovyBee) it shows
                      how to create a maximum size IntyBASIC program.
                    o When using --jlp option the stack is now keep in internal
                      system RAM.
                    o Generates warning if value bigger than 8 bits assigned
                      to 8 bits variable. Note this is a warning instead of an
                      error because sometimes are used negative values in
                      8-bits variables that can be used for arithmetic purposes
                      with another 8-bits variables and doesn't cause any harm.
                    o Generates error if TO value is bigger than 8 bits when
                      using with 8 bits variable.
                    o Generates warning for defined but unused labels.
                    o Generates error for undefined labels.
                    o Generates error for redefined labels.

v1.2.1 Aug/16/2015  o Added #BACKTAB array (direct access to screen)
                    o Optimized code generation for POKE.
                    o Optimized plus constant followed by minus constant.
                    o Solved bug where block IF code generation was wrong.
                    o Solved bug where it got stuck in DEF FN with syntax errors.
                    
v1.2   Aug/08/2015  o New option -w for disabling compilation warnings.
                    o Strings now allowed in DEF FN and as arguments to macro.
                    o Added support for block IF/ELSEIF/ELSE/END IF.
                    o Added statement DO/LOOP
                    o Added statement EXIT, use as EXIT FOR, EXIT WHILE or EXIT DO.
                    o New LEN() function.
                    o New POS() function.
                    o Added automatic seed of pseudorandom generator with RAM trash.
                    o Initializes ECS PSG sound.
                    o Error or warning inside INCLUDE indicates file.
                    o Solved bug where nested macros wouldn't work.
                    o Solved several bugs in macros for constant multiplication.
                    o Added new contribution (tcg.bas) by catsfolly.
                    o Many enhancements for the IntyColor utility.
                      o Option -m for creating MOB (for third/fourth color in same block)
                      o Option -c to not include constants.c (option -m)
                      o Option -r to create BMP report colored (error/GRAM/GROM)
                      o Option -g to indicate how to use the MOB (use with -m)

v1.1   Jul/14/2015  o New RANDOM() function
                    o New DEF FN statement for macro expressions.
                    o Experimental CONT3 and CONT4 support, no keypad decoding (ECS)
                    o INCLUDE now allows quotes and searchs also in library path.
                    o Generates warning for assigned/non-read variables and also
                      for read/non-assigned variables.
                    o Multiplication algorithm optimized (no more successive addition
                      that could take a long time, 2 seconds in worst case)
                    o New #MOBSHADOW array.
                    o New fast division/remainder algorithm for special case of only
                      variables as arguments.
                    o Solved bug where multiplication by 0 would take a long time.
                    o Now optimizes multiplication by $0200, $0400 and $0800.
                    o Solved bug where ECS code was always included.
                    o Solved bug where some divisions were signed.
                    o More optimization at code generation when the right operand
                      is the most complex.
                    o Some peephole optimization for code generation (at last
                      saves code internally for further processing)
                        * Avoids reloading register with constant if still available
                        * Avoids reading memory in register if just written
                        * Combines pairs of instructions in more optimum ways.
                        * Array reading array(const) is more optimum
                        * Common subexpression removal for simple index into array.
                        * Optimization for multiple substraction.
                        * Optimization for comparisons.
                        * Optimization for IF expr THEN GOTO.
                    * New contributions: keypad (GroovyBee), intro (Tarzilla) and
                      Hello (DZ-Jay)

v1.0.4 Apr/23/2015  o Added support for ECS secondary PSG (only in SOUND)
                    o Added RAND(range) for getting random number in range 0..range-1
                    o Slight optimization in PRINT with spaces.
                    o Modulus optimizes every power of 2.
                    o Multiplication by 32, 64 and 128 optimized.
                    o Division by 32, 64 and 128 optimized.
                    o Added intvnut routine for fast multiplication (included
                      only if you use variable * variable)
                    o Solved bug where RETURN inside IF was taken as RETURN at
                      end of PROCEDURE.
                    o Solved bug in 8-bit and 16-bits variables space counting.
                      Now it is exact.

v1.0.3 Feb/17/2015  o Added new parameter PLAY NONE
                    o Added new statements WHILE/WEND
                    o Added SGN function.
                    o It doesn't take some statements as a label if followed by
                      colon.
                    o Returns error code to command shell in case of compilation
                      error or warning.

v1.0.2 Jan/25/2015  o Support for changing title of compiled program. (it's
                      shown by emulators and multicarts)
                    o Support for Cuttle Cart 3 extra RAM. (same as JLP but
                      without hardware acceleration for multiplication and
                      division)
                    o Support for CONT.* syntax, checks both controllers.
                    o Support for ON FRAME GOSUB.

v1.0.1 Dec/12/2014  o Statements DEFINE, SCREEN and PLAY allow to use an array
                      as reference, in order to ease dynamic modification of
                      data.
                    o DEFINE statement allows VARPTR syntax.
                    o Corrected total of free variables, it indicated one more
                      than available.
                    o Again optimized code generation for PRINT.
                    o Optimized code generation for array access and PEEK.
                    o Optimized code generation for trees of addition and
                      substraction with constant.
                    o Uses ultra-optimized macro for multiplication up to 127.
                      (provided by DZ-Jay)
                    o Speed up of code for keypad decoding.
                    o Windows version of IntySmap, I forgot to include it before!
                    o Many thanks to Kiwi for contributing Apple Catcher as a
                      game sample.
                    o Many thanks to catsfolly for contributing Clowns&Ballons
                      as a game sample.

v1.0  Nov/21/2014   o PRINT allows to display decimal numbers using a library
                      provided by intvnut.
                    o Support for Intellivoice via VOICE statement.
                    o Added --jlp switch for support of multiplication/division
                      acceleration via hardware.
                    o --jlp switch also activates use of 16-bits RAM memory at 
                      $8040-$9f7f (almost 8000 words for arrays/variables)
                    o Added ABS function.
                    o Added support for READ A(x)
                    o Added USR function to call easily assembly functions.
                    o Added VARPTR function to pass addresses to assembly functions.
                    o Added DEFINE ALTERNATE
                    o Optimization of code generation for expressions involving
                      substraction and cases a+(-b) and a-(-b).
                    o Optimization of code generation for IF A AND 2
                    o Optimization of code generation for PRINT with strings.
                    o Optimization of code generation for = and <> with zero.
                    o Removes extra RETURN at end if the statement combination
                      RETURN/END is used.
                    o MUSIC statement alone doesn't activate tracker module. Only
                      if PLAY is used (useful to deactivate music)
                    o Warns of PROCEDURE start without ending previous PROCEDURE
                    o Warns of END used without starting PROCEDURE
                    o Added IntySmap utility for mapping assembly code to IntyBASIC
                    o Added extra information to IntyBASIC assembler output for
                      source-level debugging.
                    o Added intbas.pl script for structuring directories.

v0.9  Oct/10/2014   o Added ON GOTO/GOSUB statement.
                    o Added STACK_CHECK statement.
                    o Added INCLUDE statement.
                    o In statement DEFINE now are allowed expressions in parameters
                      for card number and total cards.
                    o Added fixed numbers 8.8 style and fixed add and substract
                      operators (+. and -.)
                    o Multiplication and division optimized for constant 256.
                    o Remainder optimized for constants 32, 64, 128 and 256.
                    o Added extra description for SOUND, MUSIC, MODE and DEFINE
                      statements.

v0.8  Aug/26/2014   o Generates warning if unable to open prologue/epilogue files.
                    o Shows total variable space used if exceeds available space.
                    o Support for binary numbers, using syntax &01010101
                    o Integrates music player and PLAY/MUSIC statements.
                    o Integrates PAL/NTSC detection.

v0.7  Apr/02/2014   o Added support to access card codes of Intellivision letters
                      in expressions.
                    o New MODE and SCREEN statements, so now all Intellivision video
                      operations are controlled with IntyBASIC statements, no further
                      need for POKE/PEEK.
                    o Comparisons now return $ffff for true results, useful with NOT
                    o Solved bug where CONT2 wasn't working.
                    o Following two are experimental:
                      o Now CONT?.B0 B1 and B2 are checking individual buttons.
                      o Added support for controller keypads.
                    
v0.6  Mar/02/2014   Solved bug where FOR STEP would go beyond admisible values.
                    Support for constants via CONST statement. Added example
                    of sprite offset correction in SCROLL.BAS

v0.5  Feb/26/2014   Accelerated assembly language routines for collision registers.
                    Added SCROLL and BORDER statements. Support for library path
                    in arguments.

v0.4  Feb/11/2014   Solved bug in assignation to array with constant index.

v0.3  Feb/06/2014   Added DIM statement and indexed array accesses.
                    Solved bug of undetected extra characters in line.
                    Added memory limit detection for variables.

v0.2  Feb/03/2014   More definition variations available with BITMAP statement
                    Added another sample title.bas
                    Supports officially Mac OS X 10.6 (before only 10.8 and 64-bit)
                    Supports officially Linux.

v0.1  Jan/28/2014   First release


>>>>>>>>>>>>>>  Description

This is an integer BASIC compiler for Intellivision, it works as a cross compiler over a
PC, Mac or Linux and generates assembler code that can be processed by as1600 (included
with the jzintv emulator)

Platforms available:
  o PC with Windows XP or better.
  o Mac OS X 10.6 or better. (universal 32/64-bits binary)
  o Linux.

Current limitations are:
  o Division and remainder (modulus) operators treat numbers as unsigned.
  o The constants 32768-65535 don't imply unsigned numbers, if these are used in a
    comparison with variable, the variable can be marked as UNSIGNED.
  o ASM cannot be used inside DEF FN.
  o Using PRINT for numbers always show numbers as unsigned from 0 to 65535.

Usage:

  intybasic in.bas output.asm [library_path]
  intybasic --jlp in.bas output.asm [library_path]
  intybasic --cc3 in.bas output.asm [library_path]
  intybasic --title "My cute game" in.bas output.asm [library_path]

Following modules are automatically included as prologue and epilogue of your generated
code and they set important variables and helper code:

    intybasic_prologue.asm
    intybasic_epilogue.asm
    
By default these are bring from the current directory unless you choose a library path.

Afterwards you should assemble your program (using as1600)

  as1600 -o output.bin -l output.lst output.asm

And finally you can test it using jzintv or Nostalgia emulators:

  jzintv output.bin        Normal run
  jzintv --jlp output.bin  Run with JLP support
  jzintv -v1 output.bin    Run with Intellivoice support
  
Alternately you can load the program into a CuttleCart, Intellicart or LTO-Flash for
testing over a real Intellivision.

Also see below for information of source-level debugging.

Following sample programs are included:

  samples/bats.bas            Animated bats using new statements for loops
  samples/constants.bas       Constants library (used by all samples)
  samples/controller.bas      Test of Intellivision controllers
  samples/envelope.bas        How to use envelope volume generator of sound chip
  samples/flash.bas           Sample of how to use Flash memory in JLP cartridges.
  samples/frame.bas           Sample of ON FRAME GOSUB
  samples/game1.bas           A simple shooting-letter game.
  samples/game2.bas           A simple labyrinth game with enemies.
  samples/lander.bas          Lunar Lander-style game
  samples/music.bas           Simple example of music playing
  samples/pak.bas             Labyrinth game eating points with ghosts
  samples/screen.bas          MODE statement test
  samples/scroll.bas          Example of how to use scroll.
  samples/sprites.bas         Moving sprites sample.
  samples/test.bas            Test of compiler, anyway there could be hidden bugs.
  samples/title.bas           Animated tile for title screen
  samples/voice.bas           Simple example of Intellivoice

  contrib/42k.bas             Example of how to use the 42K words maximum memory map
  contrib/accel.bas           Moving sprites with subpixel fractions (intvnut)
  contrib/AppleCatcher.bas    Game Apple Catcher by Kiwi
  contrib/clowns.bas          Game Clowns & Ballons by catsfolly
  contrib/ColouredSquares.bas Uses Coloured Squares mode to draw Bresenham lines
  contrib/constants.bas       Constants library (same as samples)
  contrib/Gram2GromFont.bas   Converts GROM font to different fonts. (GroovyBee)
  contrib/hello.bas           Hello World by DZ-Jay
  contrib/intro.bas           Intro to IntyBASIC by Tarzilla
  contrib/keypad.bas          Keypad test by GroovyBee
  contrib/tcg.bas             Trollish Comment Generator by catsfolly
  contrib/TinyFont.bas        Small font generator at 40 columns (GroovyBee)

Following utilities are included:

  IntyColor            Converts a bitmap image to IntyBASIC source code/graphics
  IntySmap             Converts a smap file to reference IntyBASIC source code.
                       Useful with jzintv debugger (option -d and --src-map)
                       See section below for full information.


>>>>>>>>>>>>>>  Supporting the developer

If you find IntyBASIC useful, please show your appreciation making a donation
via Paypal ($9 USD suggested) to b-i+y-u+b-i (at) gmail.com

If you find a bug, please report to same email and I'll try to look into
it. Because lack of time I cannot guarantee it will be corrected.


>>>>>>>>>>>>>>  IntyBASIC language specification:
  
Execution starts at init of BASIC program.

Syntax per line:
  [label:] statement[:statement] [' comment][\]

  MAIN:    PRINT "HELLO"  ' Prints hello
  
Multiple statements are allowed separated by colon.
Variables are created simply by being used.
Labels are created simply by being used.

A variable name starts with a letter or # and follows with letter, number or
underscore.

Variables and arrays (see DIM and bottom section for "exact" variables allowed) can
be 8-bits (minimum 179 available) or 16-bits size (minimum 28 available), by
default variables are 8-bit, to use 16-bits size use # as start character in name.

    x
    y
    #score
    
Note that if you use the # prefix you should use it in all your program, variables
without # prefix are treated as different 8-bit variables.
    
All variables start containing zero value. Also IntyBASIC will warn you if you
exceed the number of available variables.

Concatenation of lines is provided by the \ character, it concatenates the
current line with the following line as a single long line. So this is valid:

     PR\
     INT\
      "HELL\
     O"
    
And will be processed as PRINT "HELLO"

Following statements are available:

  REM comment      
  ' comment
  
     Everything since REM to end of line is a comment
    
  SIGNED name[,name]
  
     Indicates the names are signed variables/arrays.
     
     This only affects to the 8-bits variables that are unsigned by
     default.
     
     Note this adds two instructions to extend sign to each 8-bit signed
     variable read, although IntyBASIC will try to optimize them out.
     
     Usually you can develop your programs without using this keyword,
     but it's available if you require it.

  UNSIGNED name[,name]
  
     Indicates the names are unsigned variables/arrays.
     
     This only affects to the 16-bits variables when doing comparisons
     of less or greater than, including FOR statements.

     Note this can add one extra instruction to each comparison, this
     depends on comparison direction.

     Very useful for score routines up to 65535 or to create subroutines
     for values of 32 bits.

  CONST [name]=[constant expression]
  
     Assigns a name to a constant expression. The compiler will replace this
     name in expressions with the number. These names have priority over
     variables.
    
     This is a kind of directive, it doesn't generate code and it can appear
     anywhere in the program but it will be taken as constant from the point
     of appearance onwards.
  
  GOTO label        
  
     Go to label
  
  GOSUB label       
  
     Go to subroutine at label (must be PROCEDURE)
  
  label: PROCEDURE
  [code for subroutine]
  END
  
     Create a PROCEDURE callable by GOSUB
     It's important that PROCEDURE is in same line as label

  RETURN            
  
     Return from subroutine

  FOR A=start TO end [STEP increment]
  NEXT     ' Also supported NEXT A
  
  FOR A=1 TO 5 ' Loop
  [Variable A will contain 1,2,3,4,5]
  NEXT A
  
  FOR A=1 TO 5 STEP 2
  [Variable A will contain 1, 3, 5]
  NEXT A
  
  FOR A=5 TO 1 STEP -2
  [Variable A will contain 5, 3, 1]
  NEXT A
  
     Looping statement.
     
     Note you can only use normal variables for loop, not array variables.
     
     There is a small quirk if you're using 8-bits variables and the TO expression
     is pretty complex and reachs 0 or 255, the loop can be infinite.
     
  WHILE expr:[statement]:WEND
  WHILE expr
  [statement]
  WEND
  
     Looping statement while expression evaluates to non-zero.
     
  DO WHILE expr:[statement]:LOOP
  DO WHILE expr
  [statement]
  LOOP

  DO UNTIL expr:[statement]:LOOP
  DO UNTIL expr
  [statement]
  LOOP
  
  DO:[statement]:LOOP WHILE expr
  DO
  [statement]
  LOOP WHILE expr
  
  DO:[statement]:LOOP UNTIL expr
  DO
  [statement]
  LOOP UNTIL expr
  
     Looping statement WHILE expression evaluates to non-zero, or UNTIL
     expression evaluates to non-zero.
     
  EXIT FOR
    
     Exits current FOR loop, jumps exactly after NEXT.

  EXIT WHILE
  
     Exits current WHILE loop, jumps exactly after WEND.
     
  EXIT DO
     
     Exits current DO loop, jumps exactly after LOOP.

  IF expr GOTO [label]
  IF expr THEN [statement]
  IF expr THEN [statement] ELSE [statement]

  IF expr THEN
    [statement]
  END IF
  
  IF expr THEN
    [statement]
  ELSE
    [statement]
  END IF
  
  IF expr THEN
    [statement]
  ELSEIF expr THEN
    [statement]
  END IF

  IF expr THEN
    [statement]
  ELSEIF expr THEN
    [statement]
  ELSE
    [statement]
  END IF

     Decision statement


  ON expr GOTO [label],[label],[label]
  ON expr GOTO [label],,[label]
  ON expr GOTO ,,[label]
  ON expr GOSUB [label],[label],[label]
  ON expr GOSUB [label],,[label]
  ON expr GOSUB ,,[label]
  ON expr FAST GOTO
  ON expr FAST GOSUB

     Decision statement

     The expression is evaluated and if the result is zero, the first label is taken,
     and successively.

     If GOSUB is used then you must be sure that each label goes to PROCEDURE.

     If option has no label or the expression exceeds the number of labels, execution
     flow continues with following statement after ON.

     This statement can be made faster in execution using the FAST modifier, it will
     avoid checking boundaries, if your list of labels doesn't cover the full
     expression range then your PROGRAM WILL CRASH.'

  ON FRAME GOSUB label
  
     On each video frame interrupt, the IntyBASIC support code will call
     the indicated label.
     
     Note this doesn't generate any code and only should appear one time in your
     program.
     
     Also it could be called even before your initialization routines are ready.

     The only valid assumption is that every single variable is zero after booting.

     Also it's your responsability that the code doesn't take too long, otherwise
     video frame interrupts will accumulate and your memory stack will overflow.

  POKE address,data
  
     Poke memory with data

  WAIT
  
     Waits for next frame interruption (1/60 sec. for NTSC or 1/50 for PAL)

  OPTION WARNINGS ON
  OPTION WARNINGS OFF

     Enable/disable the compilation warnings. Note that if you disable warnings
     at the end of your program, you will not have the list of non-used variables.

  OPTION EXPLICIT
  OPTION EXPLICIT ON
  OPTION EXPLICIT OFF

     Makes obligatory to declare each variable with DIM before being used.

  DIM variable
  DIM variable[,variable]
  
     Declares a variable.
     
     Useful in combination with OPTION EXPLICIT.
     
     UNSIGNED and SIGNED are still applied separately.

  DIM var(size)
  
     Creates an array of data called 'var' of size 'size' elements,
     counting starts on zero, so DIM A(10) creates an array of 0 to 9.
     
     Also you can create arrays of 16-bits numbers, using DIM #BIG(10)

     The array can be accessed as follows:
     
         A(1)=A(1)+5
         A(X)=A(Y)-2
         
     This is a kind of directive, it doesn't generate code and it can appear
     anywhere in the program.

  RESTORE label
  READ var
  READ var,var2
label:
  DATA constant_expr[,constant_expr]
  DATA string
  DATA PACKED string
  DATA PACKED constant_expr[,constant_expr]
  DATA VARPTR a
  DATA VARPTR b(constant_expr)

    Useful to keep tables/graphics, numbers can be in the 16-bit range.
    READ will automatically limit to variable size.
    
      READ A       ' Reads data into A, limiting to 8 bits
      READ #A      ' Reads data into #A, no limitations.
                   ' Notice A and #A are different variables.
      READ A(B)    ' Reads data into A(B)
      READ #A(B)   ' Reads data into #A(B)
                   
    All data contained in DATA can also be accessed using array-syntax,
    like this:
    
      FOR A=0 TO 4
      PRINT AT TABLE(A),"Z"
      NEXT A
      
      TABLE:
      DATA 21,42,63,84,105

    String data will be converted to Intellivision character codes (just
    like in PRINT but not multiplied by 8 for screen)

    The string data with DATA PACKED will fit two Intellivision character
    codes per word (higher byte of word contains first letter, lower
    byte of word contains following letter)

    The constant data with DATA PACKED will be same. If DATA PACKED
    doesn't fill the last word in one row, it will add a zero byte to
    complete.

  DEFINE card_num,total,label
  DEFINE card_num,total,VARPTR label(expr)
  DEFINE ALTERNATE card_num,total,label
  DEFINE ALTERNATE card_num,total,VARPTR label(expr)

    Loads graphics in GRAM "card_num" (0-63) for a total of "total" cards.
    label points to graphics. (DATA or BITMAP)
    
    Label can be also an 16-bits array for dynamically defined GRAM.
    
        DIM #graphic(4)
        
        DEFINE 0,1,#graphic
    
    And the VARPTR syntax allows to select a bitmap from multiple definitions.

    Graphics will be loaded in next frame (WAIT)
    
    Note there is an approximate limit of loading 18 GRAM cards per frame
    (measured with emulator in NTSC mode)
    
    This limit is reduced to 16 GRAM cards per frame when using the music player
    (PLAY statement)
    
    Note there are two DEFINE: DEFINE and DEFINE ALTERNATE, this allows you to
    change two cards sets in one frame. Because if you use DEFINE multiple times
    per frame only the latest one is taken in account.

  SOUND 0,[VALUE 12 bits],[VOL 0-15]       Channel A
  SOUND 1,[VALUE 12 bits],[VOL 0-15]       Channel B
  SOUND 2,[VALUE 12 bits],[VOL 0-15]       Channel C
  SOUND 3,[VALUE 16 bits],[TYPE 0-15]      Volume envolvent (frequency/shape)
  SOUND 4,[NOISE 5 bits],[MIX]      Noise and mix register ($38 value by default)

  Only for the secondary PSG in ECS add-on module
  SOUND 5,[VALUE 12 bits],[VOL 0-15]       Channel A
  SOUND 6,[VALUE 12 bits],[VOL 0-15]       Channel B
  SOUND 7,[VALUE 12 bits],[VOL 0-15]       Channel C
  SOUND 8,[VALUE 16 bits],[TYPE 0-15]      Volume envolvent (frequency/shape)
  SOUND 9,[NOISE 5 bits],[MIX]      Noise and mix register ($38 value by default)


    Desired frequency value can be calculated as:
    
       value = (3579545 / 32 / frec)
       
    Please note this changes for PAL.
       
       value = (4000000 / 32 / frec)
       
    Only a constant (0-9) can be used in first parameter for SOUND.
    
    For channels A, B and C, if you use volume 48 the PSG will use the
    volume envolvent (see SOUND 3)
    
    Use volume 0 to deactivate sound channels instead of mixer bits, also don't use
    zero value for frequency parameter in channel A, B or C, it's better to use 1 in order
    to get a fast response when changing frequency.
    
    More info about PSG at:
    
      http://spatula-city.org/~im14u2c/intv/jzintv-1.0-beta3/doc/programming/psg.txt
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_100.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_101.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_102.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_103.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_104.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_105.png

    If you use the music player the SOUND capabilities are affected, check below
    the statement PLAY.

  SPRITE index,x,y,f
  
    The first parameter indicates number of MOB (0-7). Note that if you use a constant
    the generated code will be faster. Sprite (MOB) will be updated in next frame.
    
    X contains coordinate X (0-168)
    bit 8 = Interaction (suggested always 1)
    bit 9 = Visibility (suggested always 1)
    bit 10 = Double size X
    
    Y contains coordinate Y (0-95)
    bit 7 = Draw 16-line sprite. (it should be aligned in even GRAM boundary 0/2/4/8 etc)
    bits 9-8 = Scale 00= 0.5x, 01= 1x, 10= 2x, 11= 4x
    bit 10 = X flip
    bit 11 = Y flip
    
    F contains color and card number
    bits 2-0 = Lower bits of color
    bits 11-3 = Card number (0-255 for GROM, 256-319 for GRAM)
    bit 12 = Upper bit of color
    bit 13 = Change color stack.
    
    The X,Y,F values are written as-is to STIC, please check specifications at:

      http://spatula-city.org/~im14u2c/intv/jzintv-1.0-beta3/doc/programming/stic.txt
    
  CLS
  
    Clear screen to 0.
    Also resets cursor position to top-left screen.

  PRINT [AT [expr]][COLOR [expr]][,]"string"[,"string"]
  
    Prints string in current cursor coordinate (or selected via AT value 0-239)
    String is automatically converted from ASCII to Intellivision characters
    and XORed with current color ($0000-$0007, $1000-$1007 or $2000 for color stack)
    
    For Foreground/Background mode, use $0000-$0007, and $0200 is bit 0 of background
    color, $0400 is bit 1 of background color, $1000 is bit 2 of background color
    and $2000 is bit 3 of background color. (check MODE statement below)
    
    Note cursor position is not limited so you can write out of screen and crash
    your program.
    
    If you want to use GROM >= 96 or GRAM (256-319) you can use the inverted
    slash as escape (by example \96\256\319)
    
    If you want to use double quotes inside a string you can escape it this way \"
    
    Samples of positioning:
        PRINT AT 0,"A" ' for upper-left corner
        PRINT AT 19,"B" ' for upper-right corner
        PRINT AT 220,"C" ' for bottom-left corner
        PRINT AT 239,"D" ' for bottom-right corner
        
    Example:
    
        PRINT AT 84 COLOR (RAND AND 7),"HELLO WORLD"
        PRINT "HELLO WORLD"  ' Starts in previous cursor position
  
  PRINT <>expr          ' Simple number
  PRINT <const>expr     ' Right-aligned with zeroes to 'const' size.
  PRINT <.const>expr    ' Right-aligned with spaces to 'const' size.
  
    Prints decimal number in current position using current color.
    
    You can add AT and COLOR options.
    
    Example:

        PRINT AT 5 COLOR 6,"Score:",<6>#score,"00"
  
  PRINT [AT [expr],]expr[,expr]
  
    Pokes 12-bits value directly into screen, useful for variable things and GRAM
    cards.
    
    For format please check STIC specification cited upwards or the F description
    of SPRITE
    
    Also increases cursor position.
    
    Example. Printing a digit in yellow:
    
        PRINT (DIGIT+16)*8+6
        
  SCROLL [offset_x],[offset_y],[move_screen]
  
    Allows you to scroll the screen pixel by pixel. Offset X and Y can be any
    number between 0 and 7.
    
    Once you pass the frontier of 8 pixels, you can issue a move_screen command
    like this:
    
        1 = Scroll leftwards
        2 = Scroll rightwards
        3 = Scroll upwards
        4 = Scroll downwards
    
    The command will be processed in next frame or interrupt.
    
    Note once you use SCROLL statement, automatically you'll have slightly
    less 16-bits variables because there is need for a buffer and IntyBASIC
    will include extra code for scrolling.
    
    Also note that Intellivision video chip (STIC) requires you to correct
    sprite position when using scrolling. Check the sample SCROLL.BAS
    
  BORDER [color],[mask]
  
    Allows you to choose the border color also to mask the edges for scrolling.
    
    Color can be any number between 0 and 15.
    
    Mask can be 0, 1 (mask left column), 2 (mask top row) or 3 (mask both)
    
    Border and mask will be updated in next frame.
    
  MODE 0,color1,color2,color3,color4
  MODE 1
  
    Allows to select the video mode (Color Stack mode or Foreground/Background mode)
    this happens in the next video frame (WAIT)
    
    Note you cannot use PRINT COLOR until WAIT has been used, because the color
    variable is used to save data, after this COLOR will be reset to 7.
    
    In Color Stack mode you can choose the four background colors available in range
    0-15.
    
    In Foreground/Background mode you have access to 16 background colors but you
    only can use cards 0-63 (basic character set and uppercase letters) and the
    defined cards 256-319.

    By default IntyBASIC starts in Color Stack mode.

  SCREEN label[,origin_offset,target_offset,cols,rows]
  SCREEN label[,origin_offset,target_offset,cols,rows,origin_width]

    Allows to copy screen data to video the fastest way. Using only "SCREEN label"
    copies a full screen 20x12 cards to video.

    'label' points to a label inside your program containing the data for the
    screen, similar to this:
    
      my_screen:
        DATA $0007,$000F,$0007,$000F   ' And so...
        
    origin_offset is the offset (0-199 or bigger) inside the origin screen
    target_offset is the offset (0-199) inside the target video screen.
    cols is the size in columns of your copy.
    rows is the size in rows of your copy.
    origin_width is the origin screen width, useful to copy a window of a
                 big graphic screen, like a map or when scrolling horizontally.
                 (if not used, by default it's 20 as in Intellivision screen
                 width)
    
    This can serve to displace large elements in video, or to display beautiful 
    graphics screens.
    
    Label can be also an 16-bits array for dynamically drawn elements.
    
        DIM #cards(4)
        
        SCREEN #cards,0,0,4,1


  BITMAP "00000000"
  BITMAP "00001111"
  
  BITMAP "________"
  BITMAP "____XXXX"
  
    Allows you to draw using binary, you should put BITMAP statements in pairs as
    they are declared in assembler using DECLE
    
    Most useful attaching a label and using along DEFINE.
    
    Characters taken as zero include: "0" "_" " " "."
    Every other character will be taken as one.
    
  PLAY SIMPLE
  PLAY SIMPLE NO DRUMS
  PLAY FULL
  PLAY FULL NO DRUMS
  
    Activates music player and selects type of music played, SIMPLE will use only
    two channels, allowing user to use SOUND 2 for sound effects.
    
    FULL will use all three channels. SOUND cannot be used in this case.
    
    The music player will play drums using the noise channel and mix register,
    you can deactivate this using the NO DRUMS syntax, for example if you want
    to create explosion sounds on noise channel, allowing you to use SOUND 4.

    Note every frame the music player will update the sound channels.
    
    Note that if you use the NO DRUMS syntax it's needed for you to insert
    this statement just after the PLAY statement in order to put the right
    value to mix register: (the player will not modify it)
    
      SOUND 4,,$38

  PLAY NONE
  
    Deactivate music player. Following this the user should turn off the sound
    channels, using this code:
    
      SOUND 0,1,0
      SOUND 1,1,0
      SOUND 2,1,0
      SOUND 4,1,$38

  PLAY VOLUME expr

     Set volume for music playing (0 is silence, 1 is minimum volume, 15 is
     maximum volume)
     
     If you use this statement, don't forget to put PLAY VOLUME 15 at start of
     your program, because volume will be 0 at start (silence).

     Note this will include extra code inside your program (around 300 words)
     and will use slightly more cycles in each video frame.

  PLAY label
  
    Play music pointed by 'label'.
    
    label can also be a 16-bits array for loading dinamically generated music.
    
    IntyBASIC will include automatically extra code for a music player.
    
    Music must be in this format: (each MUSIC statement can contain upto 8 arguments)
    
        label:  DATA 8       ' Ticks per note (there are 50 ticks per second)
                MUSIC F4,A4#,C5
                MUSIC S,S,S
                MUSIC -,-,-

                MUSIC REPEAT
                MUSIC STOP
                MUSIC JUMP label    ' Jump to label (useful for separate intro in looping music)

                MUSIC GOSUB label   ' Go to subroutine at label (only one level)
                MUSIC RETURN        ' Return from subroutine

                MUSIC SPEED const   ' Set ticks per note starting here
                MUSIC VOLUME const  ' Set volume for music starting here (same as PLAY VOLUME)

                MUSIC C4,F4,- ' Note how C4 extends along 4 tempos and F4 only 2
                MUSIC S,S,-
                MUSIC S,-,-
                MUSIC S,-,-
                
    Identifiers for notes: Note C, D, E, F, G, A, B followed by octave (2-6), also
                           available C7
                           Optionally add # symbol for sharp.

                           Optionally add W for instrument 0 (piano),
                           X for 1 (clarinet), Y for 2 (flute), Z for 3 (bass)
                           
                           Setting instrument carries along in each channel for
                           following MUSIC statements if these doesn't specify
                           instrument.
                           
                           Note instruments waveform can be altered modifying the
                           intybasic_epilogue.asm file per program.

                           Also user can put S to sustain previous note.
                           Also user can put - for silence.
        
                           The fourth/eight argument for MUSIC allows simple drums:
                             Valid values are:
                                -  none
                                M1 strong
                                M2 tap
                                M3 roll

    IntyBASIC will detect automatically PAL/NTSC Intellivision and will adjust 
    music timing accordingly.

    Note that if you use more than 4 channels, then the tracker automatically will
    turn on ECS support to allow you to play 8 channels. (4 in base PSG and 4 in ECS
    PSG)

    Note also if you use ECS support then all your MUSIC statements should integrate
    more than 4 arguments, use at least one silence in 5th argument as play format
    will be 64 bits instead of 32 bits.

  PLAY OFF
  
    Stops music
    
  VOICE INIT
  
    Stops playing any voice in Intellivoice and empties queue.

    The usage of any VOICE statement will cause IntyBASIC to include
    automatically extra code for Intellivoice initialization at start
    of program.

    For no reason your program should restart execution (via assembler
    code) from the very start of code (address $5000 or $4800) because
    Intellivoice could hang the system. 

  VOICE PLAY label
  
    Starts speaking the voice indicated by label.

    If there is another phrase being spoken or queued then it will be
    queued in the last position.

    If the queue is full then the phrase will be lost.
    
    label can be an 16-bits array in order to built phrases dynamically.
    
  VOICE PLAY WAIT label
  
    Starts speaking same as VOICE PLAY but will stop the execution
    until all phrases in queue have been spoken.
    
    label can be an 16-bits array in order to built phrases dynamically.
    
  VOICE WAIT
  
    Waits for voice queue to be empty.
    
  VOICE NUMBER expr
  
    Says expression as a number, same as VOICE PLAY, it will accumulate
    in queue if already being spoken.

  VOICE phrases[,phrases]
  
    Data for phrases, use 0 to finish a phrase, for example:
    
        VOICE INIT
        VOICE PLAY WAIT numbers
        VOICE PLAY WAIT lets_play
        VOICE NUMBER 147
    loop:
        GOTO loop
        
    numbers:  VOICE ONE,THREE,SIX,HUNDRED,0
    
    lets_play: VOICE LL, EH, EH, PA1, TT2, SS, PA2, PP, LL, EH, EY, PA2, 0
    
    Allowed phrases are:
    
        PA5, PA4, PA3, PA2, PA1
        MATTEL, ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE
        TEN, ELEVEN, TWELVE, THIRTEEN, FOURTEEN, FIFTEEN, SIXTEEN, SEVENTEEN
        EIGHTEEN, NINETEEN, TWENTY, THIRTY, FOURTY, FIFTY, SIXTY, SEVENTY
        EIGHTY, NINETY, HUNDRED, THOUSAND, TEEN, TY, PRESS, ENTER, OR, AND
        AA, AE1, AO, AR, AW, AX, AY, BB1, BB2, CH, DD1, DD2, DH1, DH2, EH,
        EL, ER1, ER2, EY, FF, GG1, GG2, GG3, HH1, HH2, IH, IY, JH, KK1,
        KK2, KK3, LL, MM, NG1, NN1, NN2, OR2, OW, OY, PP, RR1, RR2, SH, SS
        TH, TT1, TT2, UH, UW1, UW2, VV, WH, WW, XR2, YR, YY1, YY2, ZH, ZZ


  FLASH INIT
  
    This should be the first thing called if you're using the FLASH
    functions.
    
    It only needs to be put one time at start of program.

    The default size will be 16, equivalente to 128 rows of Flash memory.

  FLASH INIT SIZE constant_expression

    Same as FLASH INIT but sets the default size.

    A size of 1 will assign 8 rows for Flash memory (one erasable sector)

    A size of 2 will assign 16 rows for Flash memory (two erasable sectors)

    And so on.

  FLASH ERASE row
  
    Erases the row number given by the expression. The row number can
    run from FLASH.FIRST to FLASH.LAST
        
    It erases a full >sector< a multiple of 8 rows. So erasing any row inside
    in a multiple of 8 will erase the 8 consecutive rows.

    You need to invoke IntyBASIC with --jlp command line option

  FLASH READ row,VARPTR #array(0)
  
    Reads the row number given by the expression and puts content inside array
    (must be 16 bits and 96 elements). The row number can be from FLASH.FIRST
    to FLASH.LAST

    You need to invoke IntyBASIC with --jlp command line option

  FLASH WRITE row,VARPTR #array(0)
  
    Writes the row number given by the expression with content from array
    (must be 16 bits and 96 elements at least). The row number can be from
    FLASH.FIRST to FLASH.LAST.

    Note that it can write only a >erased< row, this means that once written
    a row it cannot be written again until its sector is erased.

    You need to invoke IntyBASIC with --jlp command line option
    
    Don't forget to use the option --jlp in jzintv and --jlp-savegame=file

    WARNING: YOUR INTYBASIC PROGRAM WILL TURN THE SCREEN BLACK AND STOP FOR A
    FEW MILLISECONDS WHILE THE JLP FLASH OPERATIONS COMPLETE, THIS INCLUDES
    MUSIC IN BACKGROUND.


  DEF FN func = RAND % 10
  DEF FN screen_off(row, col) = (row * 20 + col)
  DEF FN resetsprite(number) = SPRITE number,0

    Allows to define functions with any number of arguments.
    
    Note these are taken as macros, the arguments are replaced as-is and the text of
    the function is inserted as-is after argument replacement. (because of that the
    parenthesis in screen_off expression)

    For example, the two upper functions could be called as:
    
          A = func
          PRINT AT screen_off(4,8),"HELLO!"
          resetsprite(0)

    Please note that although it's possible to reuse internal function names, when
    called the internal functions have priority over DEF FN (that is DEF FN is
    ignored)

  STACK_CHECK
  
    This statement anywhere in your program will activate a code that will check for
    stack overflow in the video interrupt routine.
    
    If the stack exceeds the allowed limit, it will stop the program and show a
    prominent warning message in screen saying "Stack overflow"
    
    This happens commonly when doing GOSUB to PROCEDURE and getting out of it with
    GOTO instead of RETURN.
    
  INCLUDE "filename.bas"
  
    Allows to include another file inside the current IntyBASIC program, note you
    cannot use INCLUDE recursively.
    
    Also the INCLUDE allows you to include anywhere in your program, even you could
    have half a procedure in the main file and the rest of it in the included file.
    
    Very useful to separate graphics and screen files.

    It will try to include first from the current directory and then will try adding
    the library path provided in the command line.

  CALL NAME        Calls assembly function NAME without arguments
  CALL NAME(expr)  Calls assembly function NAME with one argument in R0
  CALL NAME(expr,expr)  Calls assembly function NAME with two arguments in R0 and R1
                    (up to 4 allowed)

  ASM code
  
    Allows you to insert directly assembly code. It's copied directly to output.
    
    It's also very useful to include assembly code modules, like this:
    
        ASM INCLUDE "yourfile.asm"
        

>>>>>>>>>>>>>>  Expression syntax

The expression syntax is like a calculator.

Usual precedence rules applies to expression operators (addition and substraction have
lesser priority than multiplication and division)
  
  A=5               Decimal number
  A=$1000           Hexadecimal number
  A=&10101          Binary number
  #A=1.5            Fixed number (translated to $8001, note high byte is fraction)
                    Note use of 16-bits variable
                    
  A="C"             Intellivision card code for letter
  A=B               Simple assignment
  A=A+B             Simple addition
  A=A-B             Simple substraction
  #A=#A+.#B         Fixed addition (note use of 16-bits variables)
  #A=#A-.#B         Fixed substraction (note use of 16-bits variables)
  A=A*B             Simple multiplication
                    Multiplication by 2/4/8/16/32/64/128/256/512/1024/2048/4096 is
                    internally optimized.
                    Multiplication by constants less than 128 is optimized with macro.
                    Multiplication uses a shift algorithm that is relatively
                    efficient for most cases. (42 minimum or 702 cycles in worst case)
                    Multiplication of variable by variable uses intvnut's fast multiply routine (fixed 272 cycles)
                    When using --jlp switch the multiplication is accelerated by hardware
  A=A/B				Simple unsigned division (done by repeated substraction, it can be slow)
                    Division by 2/4/8/16/32/64/128/256 is internally optimized.
                    Division of variable by variable uses my fast division routine (214 to
                    517 cycles)
                    When using --jlp switch the division is accelerated by hardware
  A=A%B				Simple unsigned remainder
                    Note it does remainder by repeated substraction (can be slow)
                    Remainder by powers of 2 internally uses AND.
                    Remainder of variable by variable uses my fast remainder routine (214 to
                    517 cycles)
  A=(A+B)-C
  A=A AND B
  A=A OR B			Note this operation is not native, so it's not efficient
  A=A XOR B
  A=NOT A
  A=-A
  A=A=B             If A and B are the same the result is $ffff (-1) else zero
  A=A<>B
  A=A<B
  A=A>B
  A=A<=B
  A=A>=B
  A=PEEK(expr)		Reads a memory location
                    PEEK always reads 16-bits data than can be processed in expression.
  A=ABS(expr)       Gets absolute value of expression (non-negative)
  A=SGN(expr)       Gets sign of expression (-1, 0 or 1)
  A=array(expr)     Access array. Array can be defined with DIM or label for DATA
  array(expr)=A     Writes array. Array can be defined with DIM. DATA not writable

  A=USR NAME        Calls assembly function NAME without arguments
  A=USR NAME(expr)  Calls assembly function NAME with one argument in R0
  A=USR NAME(expr,expr)  Calls assembly function NAME with two arguments in R0 and R1
                    (up to 4 allowed)
                    Assembly functions can put results in R0
  #A=VARPTR B       Gets pointer to variable. Useful when linking assembler routines
  #A=VARPTR C(0)    Gets pointer to array. Can be defined with DIM or label for DATA.

  CONT              Contains AND'ed $01fe and $01ff complemented content (both controllers)
  CONT.UP           Non-zero if any controller pointing up
  CONT.DOWN         Non-zero if any controller pointing down
  CONT.LEFT         Non-zero if any controller pointing left
  CONT.RIGHT        Non-zero if any controller pointing right
  CONT.BUTTON       Non-zero if any controller button pressed.
  CONT.B0           Non-zero if any controller top buttons pressed (left/right)
  CONT.B1           Non-zero if any controller bottom left button pressed.
  CONT.B2           Non-zero if any controller bottom right button pressed.
  CONT.KEY          Current pressed key (0-9 for numbers, 10-Clear, 11-Enter, 12-Not pressed)
                    In any controller.
                    Because movements can be taken as keys, it's suggested to wait for
                    CONT.KEY to contain 12 before waiting for a key.

  CONT1				Contains complemented content of address $01ff (left controller)
  CONT1.UP			Non-zero if controller pointing up
  CONT1.DOWN		Non-zero if controller pointing down
  CONT1.LEFT		Non-zero if controller pointing left
  CONT1.RIGHT		Non-zero if controller pointing right
  CONT1.BUTTON		Non-zero if controller button pressed.
  CONT1.B0          Non-zero if any of top controller buttons pressed (left/right)
  CONT1.B1          Non-zero if bottom left button pressed
  CONT1.B2          Non-zero if bottom right button pressed
  CONT1.KEY         Current pressed key (0-9 for numbers, 10-Clear, 11-Enter, 12-Not pressed)
                    Because movements can be taken as keys, it's suggested to wait for
                    CONT1.KEY to contain 12 before waiting for a key.

  CONT2				Contains complemented content of address $01fe (right controller)
  CONT2.UP          Non-zero if controller pointing up
  CONT2.DOWN        Non-zero if controller pointing down
  CONT2.LEFT        Non-zero if controller pointing left
  CONT2.RIGHT       Non-zero if controller pointing right
  CONT2.BUTTON      Non-zero if controller button pressed.
  CONT2.B0          Non-zero if any of top controller buttons pressed (left/right)
  CONT2.B1          Non-zero if bottom left button pressed
  CONT2.B2          Non-zero if bottom right button pressed
  CONT2.KEY         Current pressed key (0-9 for numbers, 10-Clear, 11-Enter, 12-Not pressed)
                    Because movements can be taken as keys, it's suggested to wait for
                    CONT2.KEY to contain 12 before waiting for a key.
                    
                    Note using the .KEY syntax will include extra code inside IntyBASIC.
                    also you should use WAIT for each .KEY reading because it's when
                    IntyBASIC process debouncing and decodes keys. Remember this uses
                    extra processor time.

                    Useful information to avoid keys pressed to be processed as movements:

                        c = cont2.button
                        IF (c = $20)+(c = $40)+(c = $80) THEN GOTO skip_disc  ' Ignore keys
                        ...disc testing...
                    skip_disc:

  CONT3				Contains complemented content of address $00ff (ECS left controller)
  CONT3.UP          Non-zero if controller pointing up
  CONT3.DOWN        Non-zero if controller pointing down
  CONT3.LEFT        Non-zero if controller pointing left
  CONT3.RIGHT       Non-zero if controller pointing right
  CONT3.BUTTON      Non-zero if controller button pressed.
  CONT3.B0          Non-zero if any of top controller buttons pressed (left/right)
  CONT3.B1          Non-zero if bottom left button pressed
  CONT3.B2          Non-zero if bottom right button pressed

  CONT4				Contains complemented content of address $00fe (ECS right controller)
  CONT4.UP          Non-zero if controller pointing up
  CONT4.DOWN        Non-zero if controller pointing down
  CONT4.LEFT        Non-zero if controller pointing left
  CONT4.RIGHT       Non-zero if controller pointing right
  CONT4.BUTTON      Non-zero if controller button pressed.
  CONT4.B0          Non-zero if any of top controller buttons pressed (left/right)
  CONT4.B1          Non-zero if bottom left button pressed
  CONT4.B2          Non-zero if bottom right button pressed

  COL0
  COL1
  COL2
  COL3
  COL4
  COL5
  COL6
  COL7
    Obtains collision between sprites for frame, better used after WAIT
    Don't forget to set the interaction bit in sprites (bit 8 of X-coordinate)
    bit 0-7 means collision against sprite number.
    bit 8 means collision against background pixel (pixel set)
    bit 9 means collision against borders

  RAND
    Obtains a pseudo-random value between 0 and 255. Updated on each video frame
    
  RAND(range)
    Obtains a pseudo-random value between 0 and range-1. Updated on each video
    frame. Note it's slower to generate, the faster generated ones are based on
    powers of 2. Also range limited to a maximum of 256.
    
  RANDOM(range)
    Obtains a pseudo-random value between 0 and range-1. Forces update of random
    number (it doesn't need a WAIT to change). Note it's slower to generate, the
    faster ones are based on powers of 2. Also range limited to a maximum of 256.

  LEN(string)
    Gives you length of a string. Very useful in combination with DEF FN
    For example for creating strings centered on screen.
    
  POS(expr)
    Gives you the current screen position (useful for PRINT AT)
    The expression is analyzed but no code generated.

  FRAME
    Obtains current frame number (0-65535, it cycles over itself)
    
  NTSC
    It will contain 1 if the Intellivision is NTSC.
    
  #MOBSHADOW(x)
    Access elements of MOB buffer (the place where is saved the SPRITE data)
    The indexes 0-23 replicate exactly the locations 0-23 of STIC.

  #BACKTAB(x)
    Access elements from the screen buffer (located at $0200-$02EF)
    
  FLASH.FIRST
    First readable/writable row of JLP Flash memory

  FLASH.LAST
    Last readable/writable row of JLP Flash memory

  MUSIC.PLAYING
    Indicates if it's playing music, zero if isn't, non-zero if playing it.

  VOICE.AVAILABLE
    Indicates if Intellivoice is available, zero if isn't, non-zero if available.

  VOICE.PLAYING
    Indicates if Intellivoice is playing samples, zero if isn't, non-zero if playing.

The fixed numbers are useful to move game elements in fractional steps, the trick is
to preserve the current coordinate in a 16 bits variable, and when using it for the
final display you should copy the value to a 8 bits variable (cutting the fixed part)
or use AND 255 or %256 as these are optimized for this purpose.

More about the fixed numbers used in IntyBASIC:

  http://atariage.com/forums/topic/229168-now-available-intybasic-compiler-v08/page-2#entry3080617


>>>>>>>>>>>>>>  Assembly language interfacing

The USR expression and the CALL statement allow you to call assembly languages
modules from inside IntyBASIC programs.

IntyBASIC expect the following conventions to be preserved:

    Before calling:
    
    R0 = Value of first argument (or trash)
    R1 = Value of second argument (or trash)
    R2 = Value of third argument (or trash)
    R3 = Value of fourth argument (or trash)
    R4 = Trash
    R5 = Location to return

    After calling:

    R0 = Value from assembly language module (only USR expression)
    R1 = Not important
    R2 = Not important
    R3 = Not important
    R4 = Not important
    R5 = Not important

If your module changes the address of Stack Pointer (R6) or messes with
previous values stored is obvious the IntyBASIC program will crash.

If your function is relatively simple:

    ASM MYFUNCTION:    PROC
    ASM                ; ... your code...
    ASM                JR R5
    ASM                ENDP
    
If your function needs more registers or calls nested functions:

    ASM MYFUNCTION:    PROC
    ASM                BEGIN  ; Really it's PSHR R5
    ASM                ; ... your code...
    ASM                RETURN ; Really it's PULR R7
    ASM                ENDP
    

>>>>>>>>>>>>>>  Some further notes

As execution is sequential unless interrupted by GOTO or GOSUB. In any of your
programs you should put GOTO at end of main block, otherwise execution could run 
freely, by example.

Example 1:

    A = 5
  stop:	GOTO stop	' Prevents BASIC running out of ROM


Example 2:

    A = 5
  stop:   GOTO stop	' Prevents execution going inside procedure

  test:	PROCEDURE
		END
        
If you insert DATA, MUSIC or VOICE data in the middle of the execution sequence,
the Intellivision processor will do strange things. So you must put your data at
the end of the program or where the execution doesn't reach it.

Example 3:

    A = 6
    DATA 5,6,7      ' Bad, this gets executed! move it after the GOTO
  stop:    GOTO stop
        
Display starts in color-stack mode, each card of the 20x12 screen can have the
bit 13 set to 1 so it avances current pointer to color-stack and changes the
background color.

In order to change the 4 color-stack predefined values, you should use this:

    MODE 0,1,2,3,4  ' Select blue color as initial color and load other 3 colors
    
The color values are in the range 0-15.
    
In order to select foreground/background mode, you should use this:

    MODE 1

IntyBASIC by default starts program in $5000 area, you have space available up to
$6fff, that is a binary of 16K.

You can measure your program checking the generated LST file created by the
assembler or the CFG file.

Anyway, you can insert ASM statements to create bigger programs, like this:

    ASM ORG $D000
    
    ASM ORG $F000
    
This way you can use the areas $D000-$DFFF and $F000-$FFFF. It's easier to
manage and calculate available space if you put only data in these areas.

Another way is to look into the generated .lst file, you can see what memory
locations are used by IntyBASIC generated code.

Using modern Flash cart and homebrew cartridge PCBs allows following
addresses to be used without additional programming:

     $2000-$2FFF
     $5000-$6FFF
     $A000-$BFFF
     $C100-$FFFF
 
As technical note, the use of any ECS feature inside your IntyBASIC program
(such as SOUND 5-9, CONT3 or CONT4) will cause your program to boot from
$4800 to disable the ECS ROM. This has the extra advantage of disabling the
standard Mattel screen that can be seen a fraction of second before
starting your program.
         
     
>>>>>>>>>>>>>>  Real number of variables allowed

The number of 8-bits variables allowed are:

        228
        
        Substract 3 if you use SCROLL
        Substract 3 if you use VOICE
        Substract 6 if you use the keypad
        Substract 26 if you use PLAY

The number of 16-bits variables allowed are:

        47 (7962 if using --jlp or --cc3 switch)
        
        Substract 20 if you use SCROLL or 30 if you use VOICE

Note each location of an array allocated with DIM counts as one variable.


>>>>>>>>>>>>>>  Generating ROM files for Nostalgia emulator
          
By default the as1600 assembler generates a .bin/.cfg pair of files, both can
be copied in the roms directory of the Nostalgia emulator for testing your
programs.

Alternately you can convert both files to a single .rom file, using the
bin2rom utility included with jzintv:

    bin2rom game.bin
    
It will generate a game.rom file that contains a mix of the .bin and .cfg file
and it's more easy to test with Nostalgia.

Another alternative is to use the following as1600 invocation to generate
.rom file in the same run:

  as1600 -o output -l output.lst output.asm

         
>>>>>>>>>>>>>>  Source code debugging

I've included enough information in the generated ASM file and with extensive
help from intvnut there is now support for basic debugging with IntyBASIC
source code shown along the way.

You need to compile your program in this way:

  intybasic input.bas output.asm
  as1600 -j output.smap -s output.sym -o output.bin -l output.lst output.asm 
  intysmap output.smap   
  jzintv -d output.bin --src-map=output.smap --sym-file=output.sym  

After this you can use normally the jzintv debug commands.

Note for Windows that your main window must be 160 columns or wider, use the
jzintv command >160 to expand window if necessary.


>>>>>>>>>>>>>>  Permissions in Mac OS X and Linux

The compressed executables for both Mac OS X and Linux probably will not have
the right permissions when uncompressed.

So is suggested to run these commands in your IntyBASIC directory:

  chmod 755 intybasic
  chmod 755 intybasic_linux

If your IntyBASIC directory is not in current path you can run it using this
while at IntyBASIC directory:

  ./intybasic game.bas game.asm

Also you can structure your IntyBASIC directories using the script intbas.pl
provided by James Pujals (DZ-Jay), the structures required are the following:

=============================================================================
FILE PATH:                              DESCRIPTION:
=============================================================================
+-- intybasic                           Installation directory
    +-- bin                             IntyBasic binary distribution
    |    |-- intbas.pl                  -> Helper script to compile/assemble
    |    |-- intybasic_linux            -> IntyBasic for Linux
    |    |-- IntyBASIC.exe              -> IntyBasic for Windows
    |    |-- intybasic                  -> IntyBasic for Mac OSX
    |    |-- intycolor                  -> IntyColor for Mac OSX
    |    |-- intyColor.exe              -> IntyColor for Windows
    |    `-- intycolor_linux            -> IntyColor for Linux
    |
    +-- examples                        BASIC sample program repository
    |    +-- game1                      Sample Project: game1
    |    |    +-- bin                   AS-1600 assembler output
    |    |    |    |-- game1.bin        \_ Game binary in BIN+CFG format
    |    |    |    |-- game1.cfg        /
    |    |    |    |-- game1.ls         -> Assembler listing file
    |    |    |    |-- game1.map        -> Assembler memory map
    |    |    |    |-- game1.rom        -> Game binary in ROM format
    |    |    |    `-- game1.sym        -> Assembler symbol table
    |    |    |
    |    |    +-- asm                   IntyBasic compiler output
    |    |    |    `-- game1.asm        -> Generated assembly source
    |    |    |
    |    |    `-- game1.bas             BASIC source file
    |    |
    |    `-- title
    |        +-- bin                    AS-1600 assembler output
    |        |    |-- title.bin         \_ Game binary in BIN+CFG format
    |        |    |-- title.cfg         /
    |        |    |-- title.ls          -> Assembler listing file
    |        |    |-- title.map         -> Assembler memory map
    |        |    |-- title.rom         -> Game binary in ROM format
    |        |    `-- title.sym         -> Assembler symbol table
    |        |
    |        +-- asm                    IntyBasic compiler output
    |        |    `-- title.asm         -> Generated assembly source
    |        |
    |        `-- title.bas              BASIC source file
    |
    +-- games                           BASIC game program repository 
    |   `-- (empty)                     Add your own programs here.
    |
    +-- lib                             IntyBasic library modules
    |    |-- intybasic_prologue.asm     -> Prologue module
    |    `-- intybasic_epilogue.asm     -> Epilogue module
    |
    |-- manual.txt                      IntyBasic manual
    `-- INTBAS - README.txt             This README file.

You need to setup some environment variables:

  INTV_SDK_PATH    =  Pointing to the directory containing jzintv structure
  INTV_BASIC_PATH  =  Pointing to the installation directory (per structure)

DZ-Jay mounted his own IntyBASIC distribution following that structure:

  http://atariage.com/forums/index.php?app=core&module=attach&section=attach&attach_id=363028


>>>>>>>>>>>>>>  Useful links

jzintv emulator (including as1600 assembler)

  http://spatula-city.org/~im14u2c/intv/

Intellivision Nostalgia emulator

  http://www.intellivision.us/intvgames/nostalgia/nostalgia.php
  
  
>>>>>>>>>>>>>>  Acknowledgments

Thanks to following members of Atariage for contributing valuable suggestions,
test programs and even support libraries:

  Albert 
  artrag
  atari2600land
  awhite2600
  carlsson
  catsfolly
  ckblackm
  CrazyBoss
  Cybearg
  DZ-Jay
  First Spear
  freewheel
  GroovyBee
  intvnut
  Jess Ragan
  Kiwi
  mmarrero
  RevEng
  SpiceWare
  Tarzilla
